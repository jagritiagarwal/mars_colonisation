
!function (t) {
  if ('object' == typeof exports && 'undefined' != typeof module) module.exports = t();
   else if ('function' == typeof define && define.amd) define([], t);
   else {
    var e;
    'undefined' != typeof window ? e = window : 'undefined' != typeof global ? e = global : 'undefined' != typeof self && (e = self),
    e.PF = t()
  }
}(function () {
  return function t(e, r, i) {
    function n(s, a) {
      if (!r[s]) {
        if (!e[s]) {
          var u = 'function' == typeof require && require;
          if (!a && u) return u(s, !0);
          if (o) return o(s, !0);
          var h = new Error('Cannot find module \'' + s + '\'');
          throw h.code = 'MODULE_NOT_FOUND',
          h
        }
        var l = r[s] = {
          exports: {
          }
        };
        e[s][0].call(l.exports, function (t) {
          var r = e[s][1][t];
          return n(r ? r : t)
        }, l, l.exports, t, e, r, i)
      }
      return r[s].exports
    }
    for (var o = 'function' == typeof require && require, s = 0; s < i.length; s++) n(i[s]);
    return n
  }({
    1: [
      function (t, e) {
        e.exports = t('./lib/heap')
      },
      {
        './lib/heap': 2
      }
    ],
    2: [
      function (t, e) {
        !function () {
          var t,
          r,
          i,
          n,
          o,
          s,
          a,
          u,
          h,
          l,
          p,
          c,
          f,
          d,
          g;
          i = Math.floor,
          l = Math.min,
          r = function (t, e) {
            return e > t ? - 1 : t > e ? 1 : 0
          },
          h = function (t, e, n, o, s) {
            var a;
            if (null == n && (n = 0), null == s && (s = r), 0 > n) throw new Error('lo must be non-negative');
            for (null == o && (o = t.length); o > n; ) a = i((n + o) / 2),
            s(e, t[a]) < 0 ? o = a : n = a + 1;
            return [].splice.apply(t, [
              n,
              n - n
            ].concat(e)),
            e
          },
          s = function (t, e, i) {
            return null == i && (i = r),
            t.push(e),
            d(t, 0, t.length - 1, i)
          },
          o = function (t, e) {
            var i,
            n;
            return null == e && (e = r),
            i = t.pop(),
            t.length ? (n = t[0], t[0] = i, g(t, 0, e))  : n = i,
            n
          },
          u = function (t, e, i) {
            var n;
            return null == i && (i = r),
            n = t[0],
            t[0] = e,
            g(t, 0, i),
            n
          },
          a = function (t, e, i) {
            var n;
            return null == i && (i = r),
            t.length && i(t[0], e) < 0 && (n = [
              t[0],
              e
            ], e = n[0], t[0] = n[1], g(t, 0, i)),
            e
          },
          n = function (t, e) {
            var n,
            o,
            s,
            a,
            u,
            h;
            for (null == e && (e = r), a = function () {
              h = [
              ];
              for (var e = 0, r = i(t.length / 2); r >= 0 ? r > e : e > r; r >= 0 ? e++ : e--) h.push(e);
              return h
            }.apply(this).reverse(), u = [
            ], o = 0, s = a.length; s > o; o++) n = a[o],
            u.push(g(t, n, e));
            return u
          },
          f = function (t, e, i) {
            var n;
            return null == i && (i = r),
            n = t.indexOf(e),
            - 1 !== n ? (d(t, 0, n, i), g(t, n, i))  : void 0
          },
          p = function (t, e, i) {
            var o,
            s,
            u,
            h,
            l;
            if (null == i && (i = r), s = t.slice(0, e), !s.length) return s;
            for (n(s, i), l = t.slice(e), u = 0, h = l.length; h > u; u++) o = l[u],
            a(s, o, i);
            return s.sort(i).reverse()
          },
          c = function (t, e, i) {
            var s,
            a,
            u,
            p,
            c,
            f,
            d,
            g,
            y,
            b;
            if (null == i && (i = r), 10 * e <= t.length) {
              if (p = t.slice(0, e).sort(i), !p.length) return p;
              for (u = p[p.length - 1], g = t.slice(e), c = 0, d = g.length; d > c; c++) s = g[c],
              i(s, u) < 0 && (h(p, s, 0, null, i), p.pop(), u = p[p.length - 1]);
              return p
            }
            for (n(t, i), b = [
            ], a = f = 0, y = l(e, t.length); y >= 0 ? y > f : f > y; a = y >= 0 ? ++f : --f) b.push(o(t, i));
            return b
          },
          d = function (t, e, i, n) {
            var o,
            s,
            a;
            for (null == n && (n = r), o = t[i]; i > e && (a = i - 1 >> 1, s = t[a], n(o, s) < 0); ) t[i] = s,
            i = a;
            return t[i] = o
          },
          g = function (t, e, i) {
            var n,
            o,
            s,
            a,
            u;
            for (null == i && (i = r), o = t.length, u = e, s = t[e], n = 2 * e + 1; o > n; ) a = n + 1,
            o > a && !(i(t[n], t[a]) < 0) && (n = a),
            t[e] = t[n],
            e = n,
            n = 2 * e + 1;
            return t[e] = s,
            d(t, u, e, i)
          },
          t = function () {
            function t(t) {
              this.cmp = null != t ? t : r,
              this.nodes = [
              ]
            }
            return t.push = s,
            t.pop = o,
            t.replace = u,
            t.pushpop = a,
            t.heapify = n,
            t.nlargest = p,
            t.nsmallest = c,
            t.prototype.push = function (t) {
              return s(this.nodes, t, this.cmp)
            },
            t.prototype.pop = function () {
              return o(this.nodes, this.cmp)
            },
            t.prototype.peek = function () {
              return this.nodes[0]
            },
            t.prototype.contains = function (t) {
              return - 1 !== this.nodes.indexOf(t)
            },
            t.prototype.replace = function (t) {
              return u(this.nodes, t, this.cmp)
            },
            t.prototype.pushpop = function (t) {
              return a(this.nodes, t, this.cmp)
            },
            t.prototype.heapify = function () {
              return n(this.nodes, this.cmp)
            },
            t.prototype.updateItem = function (t) {
              return f(this.nodes, t, this.cmp)
            },
            t.prototype.clear = function () {
              return this.nodes = [
              ]
            },
            t.prototype.empty = function () {
              return 0 === this.nodes.length
            },
            t.prototype.size = function () {
              return this.nodes.length
            },
            t.prototype.clone = function () {
              var e;
              return e = new t,
              e.nodes = this.nodes.slice(0),
              e
            },
            t.prototype.toArray = function () {
              return this.nodes.slice(0)
            },
            t.prototype.insert = t.prototype.push,
            t.prototype.remove = t.prototype.pop,
            t.prototype.top = t.prototype.peek,
            t.prototype.front = t.prototype.peek,
            t.prototype.has = t.prototype.contains,
            t.prototype.copy = t.prototype.clone,
            t
          }(),
          ('undefined' != typeof e && null !== e ? e.exports : void 0) ? e.exports = t : window.Heap = t
        }.call(this)
      },
      {
      }
    ],
    3: [
      function (t, e) {
        function r(t, e, r,stop) {
          this.width = t,
          this.height = e,
          this.nodes = this._buildNodes(t, e, r)
        }
        var i = t('./Node');
        r.prototype._buildNodes = function (t, e, r) {
          var n,
          o,
          s = new Array(e);
          for (n = 0; e > n; ++n) for (s[n] = new Array(t), o = 0; t > o; ++o) s[n][o] = new i(o, n);
          if (void 0 === r) return s;
          if (r.length !== e || r[0].length !== t) throw new Error('Matrix size does not fit');
          for (n = 0; e > n; ++n) for (o = 0; t > o; ++o) r[n][o] && (s[n][o].walkable = !1) ;
          return s
        },
        r.prototype.getNodeAt = function (t, e) {
          return this.nodes[e][t]
        },
        r.prototype.isWalkableAt = function (t, e) {
          return this.isInside(t, e) && this.nodes[e][t].walkable
        },
        r.prototype.isNstopAt = function (t, e) {
          return this.isInside(t, e) && this.nodes[e][t].Nstop
        },
        r.prototype.isInside = function (t, e) {
          return t >= 0 && t < this.width && e >= 0 && e < this.height
        },
        r.prototype.setWalkableAt = function (t, e,r) {
          this.nodes[e][t].walkable = r
        },
        r.prototype.setNstopAt = function (t, e,r) {
          this.nodes[e][t].Nstop = r
        },
        r.prototype.getNeighbors = function (t, e, r) {
          var i = t.x,
          n = t.y,
          o = [
          ],
          s = !1,
          a = !1,
          u = !1,
          h = !1,
          l = !1,
          p = !1,
          c = !1,
          f = !1,
          d = this.nodes;
          return this.isWalkableAt(i, n - 1) && (o.push(d[n - 1][i]), s = !0),
          this.isWalkableAt(i + 1, n) && (o.push(d[n][i + 1]), u = !0),
          this.isWalkableAt(i, n + 1) && (o.push(d[n + 1][i]), l = !0),
          this.isWalkableAt(i - 1, n) && (o.push(d[n][i - 1]), c = !0),
          e ? (r ? (a = c && s, h = s && u, p = u && l, f = l && c)  : (a = c || s, h = s || u, p = u || l, f = l || c), a && this.isWalkableAt(i - 1, n - 1) && o.push(d[n - 1][i - 1]), h && this.isWalkableAt(i + 1, n - 1) && o.push(d[n - 1][i + 1]), p && this.isWalkableAt(i + 1, n + 1) && o.push(d[n + 1][i + 1]), f && this.isWalkableAt(i - 1, n + 1) && o.push(d[n + 1][i - 1]), o)  : o
        },
        r.prototype.clone = function () {
          var t,
          e,
          n = this.width,
          o = this.height,
          s = this.nodes,
          a = new r(n, o),
          u = new Array(o);
          for (t = 0; o > t; ++t) for (u[t] = new Array(n), e = 0; n > e; ++e) u[t][e] = new i(e, t, s[t][e].walkable,s[t][e].Nstop);
          return a.nodes = u,
          a
        },
        e.exports = r
      },
      {
        './Node': 5
      }
    ],
    4: [
      function (t, e) {
        e.exports = {
          manhattan: function (t, e) {
            return t + e
          },
          euclidean: function (t, e) {
            return Math.sqrt(t * t + e * e)
          },
          octile: function (t, e) {
            var r = Math.SQRT2 - 1;
            return e > t ? r * t + e : r * e + t
          },
          chebyshev: function (t, e) {
            return Math.max(t, e)
          }
        }
      },
      {
      }
    ],
    5: [
      function (t, e) {
        function r(t, e, r,ns) {
          this.x = t,
          this.y = e,
          this.walkable = void 0 === r ? !0 : r
          this.Nstop = void 0 === ns ? !0 : ns
        }
        e.exports = r
      },
      {
      }
    ],
    6: [
      function (t, e, r) {
        function i(t) {
          for (var e = [
            [t.x,
            t.y]
          ]; t.parent; ) t = t.parent,
          e.push([t.x,
          t.y]);
          return e.reverse()
        }
        function n(t, e) {
          var r = i(t),
          n = i(e);
          return r.concat(n.reverse())
        }
        function o(t) {
          var e,
          r,
          i,
          n,
          o,
          s = 0;
          for (e = 1; e < t.length; ++e) r = t[e - 1],
          i = t[e],
          n = r[0] - i[0],
          o = r[1] - i[1],
          s += Math.sqrt(n * n + o * o);
          return s
        }
        function s(t, e, r, i) {
          var n,
          o,
          s,
          a,
          u,
          h,
          l = Math.abs,
          p = [
          ];
          for (s = l(r - t), a = l(i - e), n = r > t ? 1 : - 1, o = i > e ? 1 : - 1, u = s - a; ; ) {
            if (p.push([t,
            e]), t === r && e === i) break;
            h = 2 * u,
            h > - a && (u -= a, t += n),
            s > h && (u += s, e += o)
          }
          return p
        }
        function a(t) {
          var e,
          r,
          i,
          n,
          o,
          a,
          u = [
          ],
          h = t.length;
          if (2 > h) return u;
          for (o = 0; h - 1 > o; ++o) for (e = t[o], r = t[o + 1], i = s(e[0], e[1], r[0], r[1]), n = i.length, a = 0; n - 1 > a; ++a) u.push(i[a]);
          return u.push(t[h - 1]),
          u
        }
        function u(t, e) {
          var r,
          i,
          n,
          o,
          a,
          u,
          h,
          l,
          p,
          c,
          f,
          d,
          g,
          y = e.length,
          b = e[0][0],
          A = e[0][1],
          k = e[y - 1][0],
          m = e[y - 1][1];
          for (r = b, i = A, a = e[1][0], u = e[1][1], h = [
            [r,
            i]
          ], l = 2; y > l; ++l) {
            for (c = e[l], n = c[0], o = c[1], f = s(r, i, n, o), g = !1, p = 1; p < f.length; ++p) if (d = f[p], !t.isWalkableAt(d[0], d[1])) {
              g = !0,
              h.push([a,
              u]),
              r = a,
              i = u;
              break
            }
            g || (a = n, u = o)
          }
          return h.push([k,
          m]),
          h
        }
        function h(t) {
          if (t.length < 3) return t;
          var e,
          r,
          i,
          n,
          o,
          s,
          a = [
          ],
          u = t[0][0],
          h = t[0][1],
          l = t[1][0],
          p = t[1][1],
          c = l - u,
          f = p - h;
          for (o = Math.sqrt(c * c + f * f), c /= o, f /= o, a.push([u,
          h]), s = 2; s < t.length; s++) e = l,
          r = p,
          i = c,
          n = f,
          l = t[s][0],
          p = t[s][1],
          c = l - e,
          f = p - r,
          o = Math.sqrt(c * c + f * f),
          c /= o,
          f /= o,
          (c !== i || f !== n) && a.push([e,
          r]);
          return a.push([l,
          p]),
          a
        }
        r.backtrace = i,
        r.biBacktrace = n,
        r.pathLength = o,
        r.interpolate = s,
        r.expandPath = a,
        r.smoothenPath = u,
        r.compressPath = h
      },
      {
      }
    ],
    7: [
      function (t, e) {
        function r(t) {
          t = t || {
          },
          this.allowDiagonal = t.allowDiagonal,
          this.dontCrossCorners = t.dontCrossCorners,
          this.heuristic = t.heuristic || o.manhattan,
          this.weight = t.weight || 1
        }
        var i = t('heap'),
        n = t('../core/Util'),
        o = t('../core/Heuristic');
        r.prototype.findPath = function (t, e, r, o, s) {
          var a,
          u,
          h,
          l,
          p,
          c,
          f,
          d,
          g = new i(function (t, e) {
            return t.f - e.f
          }),
          y = s.getNodeAt(t, e),
          b = s.getNodeAt(r, o),
          A = this.heuristic,
          k = this.allowDiagonal,
          m = this.dontCrossCorners,
          v = this.weight,
          w = Math.abs,
          x = Math.SQRT2;
          for (y.g = 0, y.f = 0, g.push(y), y.opened = !0; !g.empty(); ) {
            if (a = g.pop(), a.closed = !0, a === b) return n.backtrace(b);
            for (u = s.getNeighbors(a, k, m), l = 0, p = u.length; p > l; ++l) h = u[l],
            h.closed || (c = h.x, f = h.y, d = a.g + (0 === c - a.x || 0 === f - a.y ? 1 : x), (!h.opened || d < h.g) && (h.g = d, h.h = h.h || v * A(w(c - r), w(f - o)), h.f = h.g + h.h, h.parent = a, h.opened ? g.updateItem(h)  : (g.push(h), h.opened = !0)))
          }
          return []
        },
        e.exports = r
      },
      {
        '../core/Heuristic': 4,
        '../core/Util': 6,
        heap: 1
      }
    ],
    8: [
      function (t, e) {
        function r(t) {
          t = t || {
          },
          this.allowDiagonal = t.allowDiagonal,
         // this.dontCrossCorners = t.dontCrossCorners,
          this.heuristic = t.heuristic || o.manhattan,
          this.weight = t.weight || 1
        }
        var i = t('heap'),
        n = t('../core/Util'),
        o = t('../core/Heuristic');
       // o = t('../core/Heuristic');
       var A= this.heuristic,
       k = this.allowDiagonal,
      // m = this.dontCrossCorners,
       v = this.weight,
       w = Math.abs,
       x = Math.SQRT2;
       var p=[];
         var PL=10000000;
       r.prototype.findPath = function (t, e, r, o, grid) {
         var d=grid.getNodeAt(t,e);
        var b=grid.getNodeAt(r,o);
         var stops=[];
         stops.push(b);
         for(var i=0;i<40;i++){
           for(var j=0;j<60;j++){
             if(grid.isNstopAt(j,i)==0){stops.push(grid.getNodeAt(j,i));}
           }
         }
         //alert(stops.length);
         var vis=new Map([[d,1]]);
         
         // alert(stops.length);
          var par =new Map([[d,-1]]);
          var final=algo_ast(d,stops,grid,vis,par,this.allowDiagonal,this.heuristic);
      
     
     var e = [
      [final[0].x,
      final[0].y]
    ]; 
    
    for(var i=1;i<final.length;i++){
        e.push([final[i].x,final[i].y]);
       
        
    }
    
    return e;
  },
         
         
        ast2 = function (t, e, r, o, grid,diag,heur) {
          var SQRT2=Math.SQRT2;
          for(var x =0 ; x < 40; x++) {
            for(var y = 0; y < 60; y++) {
              grid.getNodeAt(y,x).f=0;
             // grid.getNodeAt(y,x).f=0;
              grid.getNodeAt(y,x).h=0;
              grid.getNodeAt(y,x).g=0;
              //grid[x][y].debug = "";
              grid.getNodeAt(y,x).parent = null;
            }  
          }
          var a,
          u,
          h,
          l,
          p,
          c,
          f,
          d,
          g=[],
          start = grid.getNodeAt(t, e),
          end = grid.getNodeAt(r, o);

          var openList   = [];
        var closedList = [];
        openList.push(start);
     // alert(start.x);
        while(openList.length > 0) {
    
          // Grab the lowest f(x) to process next
          var lowInd = 0;
          for(var i=0; i<openList.length; i++) {
            if(openList[i].f < openList[lowInd].f) { lowInd = i; }
          }
          var currentNode = openList[lowInd];
          //alert(currentNode.x);
          // End case -- result has been found, return the traced path
          if(currentNode===end) {
            var curr = currentNode;
            var ret = [];
            while(curr.parent) {
              ret.push(curr);
              curr = curr.parent;
            }
            ret.push(curr);
            //alert(ret.length);
            return ret;
          }
    
          // Normal case -- move currentNode from open to closed, process each of its neighbors
          openList.splice(lowInd,1);
          closedList.push(currentNode);
          var neighbors = grid.getNeighbors( currentNode,diag);
    
          for(var i=0; i<neighbors.length;i++) {
           // alert(1);
            var neighbor = neighbors[i];
            if(closedList.findIndex(closedList => closedList === neighbor)!=-1) {
              // not a valid node to process, skip to next neighbor
              continue;
            }
            var x = neighbor.x;
            var y = neighbor.y;
            
            // g score is the shortest distance from start to current node, we need to check if
            //   the path we have arrived at this neighbor is the shortest one we have seen yet
            //var gScore = currentNode.g + 1; // 1 is the distance from a node to it's neighbor
            var gScore =  currentNode.g + ((x -  currentNode.x === 0 || y -  currentNode.y === 0) ? 1 : SQRT2);
            var gScoreIsBest = false;
    
    
            if(openList.findIndex(openList => openList === neighbor)===-1) {
              // This the the first time we have arrived at this node, it must be the best
              // Also, we need to take the h (heuristic) score since we haven't done so yet
    
              gScoreIsBest = true;
              neighbor.h = heur(Math.abs(x-end.x),Math.abs(y-end.y));
              openList.push(neighbor);
            }
            else if(gScore < neighbor.g) {
              // We have already seen the node, but last time it had a worse g (distance from start)
              gScoreIsBest = true;
            }
    
            if(gScoreIsBest) {
              // Found an optimal (so far) path to this node.   Store info on how we got here and
              //  just how good it really is...
              neighbor.parent = currentNode;
              neighbor.g = gScore;
              neighbor.f = neighbor.g + neighbor.h;
              //alert(1);
              //neighbor.debug = "F: " + neighbor.f + "<br />G: " + neighbor.g + "<br />H: " + neighbor.h;
            }
          }
        }
    
        // No result was found -- empty array signifies failure to find path
        return [];
              
        },
        
        algo_ast=function (start,dest,grid,vis,par,diag,heur){
          var f=0;
          
         // var nr=new r;
          for(var i=0;i<dest.length;i++){
             // alert(vis[dest]);
              if(!(vis.has(dest[i])) || !(vis.get(dest[i]))){
                  f=1;
                  vis.set(dest[i],1);
                  par.set(dest[i],start);
                  //parent[dest[i]]=start;
                  var a=algo_ast(dest[i],dest,grid,vis,par,diag,heur);
    
                  if(a.length<PL){
                      p=a;
                      PL=p.length;
                  }
                  vis.set(dest[i],0);
                  par.set(dest[i],-1);
              }
          }
          if(f==0){
              var x=[];
              
              //alert(x[0].x);
             // alert((parent.get(start)));
              while(par.get(start)!=-1){
               // var a=new r;
    
               //x.push(par.get(start));t, e, r, o, grid,diag,heur
                  var x1=ast2(par.get(start).x,par.get(start).y,start.x,start.y,grid,diag,heur);
                  for(var i=0;i<x1.length;i++)x.push(x1[i]);
                  start=par.get(start);
                  x.push(start);
              }
             // alert(x);
              return x;
              
          }
          else return p;
      },
        
      
      
        
        e.exports = r
      },
      {
        '../core/Heuristic': 4,
        '../core/Util': 6,
       
        heap: 1
      }
      
    ],
    9: [
      function (t, e) {
        function r(t) {
          t = t || {
          },
          this.allowDiagonal = t.allowDiagonal,
          this.dontCrossCorners = t.dontCrossCorners,
          this.heuristic = t.heuristic || o.manhattan,
          this.weight = t.weight || 1
        }
        var i = t('heap'),
        n = t('../core/Util'),
        o = t('../core/Heuristic');
        r.prototype.findPath = function (t, e, r, o, s) {
          var a,
          u,
          h,
          l,
          p,
          c,
          f,
          d,
          g = function (t, e) {
            return t.f - e.f
          },
          y = new i(g),
          b = new i(g),
          A = s.getNodeAt(t, e),
          k = s.getNodeAt(r, o),
          m = this.heuristic,
          v = this.allowDiagonal,
          w = this.dontCrossCorners,
          x = this.weight,
          F = Math.abs,
          W = Math.SQRT2,
          N = 1,
          C = 2;
          for (A.g = 0, A.f = 0, y.push(A), A.opened = N, k.g = 0, k.f = 0, b.push(k), k.opened = C; !y.empty() && !b.empty(); ) {
            for (a = y.pop(), a.closed = !0, u = s.getNeighbors(a, v, w), l = 0, p = u.length; p > l; ++l) if (h = u[l], !h.closed) {
              if (h.opened === C) return n.biBacktrace(a, h);
              c = h.x,
              f = h.y,
              d = a.g + (0 === c - a.x || 0 === f - a.y ? 1 : W),
              (!h.opened || d < h.g) && (h.g = d, h.h = h.h || x * m(F(c - r), F(f - o)), h.f = h.g + h.h, h.parent = a, h.opened ? y.updateItem(h)  : (y.push(h), h.opened = N))
            }
            for (a = b.pop(), a.closed = !0, u = s.getNeighbors(a, v, w), l = 0, p = u.length; p > l; ++l) if (h = u[l], !h.closed) {
              if (h.opened === N) return n.biBacktrace(h, a);
              c = h.x,
              f = h.y,
              d = a.g + (0 === c - a.x || 0 === f - a.y ? 1 : W),
              (!h.opened || d < h.g) && (h.g = d, h.h = h.h || x * m(F(c - t), F(f - e)), h.f = h.g + h.h, h.parent = a, h.opened ? b.updateItem(h)  : (b.push(h), h.opened = C))
            }
          }
          return []
        },
        e.exports = r
      },
      {
        '../core/Heuristic': 4,
        '../core/Util': 6,
        heap: 1
      }
    ],
    
    11: [
      function (t, e) {
        function r(t) {
          t = t || {
          },
          this.allowDiagonal = t.allowDiagonal,
          this.dontCrossCorners = t.dontCrossCorners
        }
        var i = t('../core/Util');
        r.prototype.findPath = function (t, e, r, n, o) {
          var s,
          a,
          u,
          h,
          l,
          p = o.getNodeAt(t, e),
          c = o.getNodeAt(r, n),
          f = [
          ],
          d = [
          ],
          g = this.allowDiagonal,
          y = this.dontCrossCorners,
          b = 0,
          A = 1;
          for (f.push(p), p.opened = !0, p.by = b, d.push(c), c.opened = !0, c.by = A; f.length && d.length; ) {
            for (u = f.shift(), u.closed = !0, s = o.getNeighbors(u, g, y), h = 0, l = s.length; l > h; ++h) if (a = s[h], !a.closed) if (a.opened) {
              if (a.by === A) return i.biBacktrace(u, a)
            } else f.push(a),
            a.parent = u,
            a.opened = !0,
            a.by = b;
            for (u = d.shift(), u.closed = !0, s = o.getNeighbors(u, g, y), h = 0, l = s.length; l > h; ++h) if (a = s[h], !a.closed) if (a.opened) {
              if (a.by === b) return i.biBacktrace(a, u)
            } else d.push(a),
            a.parent = u,
            a.opened = !0,
            a.by = A
          }
          return []
        },
        e.exports = r
      },
      {
        '../core/Util': 6
      }
    ],
    12: [
      function (t, e) {
        function r(t) {
          i.call(this, t),
          this.heuristic = function () {
            return 0
          }
        }
        var i = t('./BiAStarFinder');
        r.prototype = new i,
        r.prototype.constructor = r,
        e.exports = r
      },
      {
        './BiAStarFinder': 9
      }
    ],
    13: [
      function (t, e) {
        function r(t) {
          t = t || {
          },
          this.allowDiagonal = t.allowDiagonal,
          this.dontCrossCorners = t.dontCrossCorners
        }
        var i = t('../core/Util');
        r.prototype.findPath = function (t, e, r, n, o) {
          var s,
          a,
          u,
          h,
          l,
          p = [
          ],
          c = this.allowDiagonal,
          f = this.dontCrossCorners,
          d = o.getNodeAt(t, e),
          g = o.getNodeAt(r, n);

          for (p.push(d), d.opened = !0; p.length; ) {
            if (u = p.shift(), u.closed = !0, u === g) return i.backtrace(g);
            for (s = o.getNeighbors(u, c, f), h = 0, l = s.length; l > h; ++h) a = s[h],
            a.closed || a.opened || (p.push(a), a.opened = !0, a.parent = u)
          }
          return []
        },
        e.exports = r
      },
      {
        '../core/Util': 6
      }
    ],
    14: [
      function (t, e) {
        function r(t) {
          i.call(this, t),
          this.heuristic = function () {
            return 0
          }
        }
        var i = t('./AStarFinder');
        r.prototype = new i,
        r.prototype.constructor = r,
        e.exports = r
      },
      {
        './AStarFinder': 7
      }
    ],
    15: [
      function (t, e) {
        
        function r(t) {
          t = t || {
          },
          this.allowDiagonal = t.allowDiagonal
          //this.dontCrossCorners = t.dontCrossCorners
        }
        //var diag=t.allowDiagonal;
      var PL=10000000;
      var p=[];
      var util = t('../core/Util');
     // var nr=new r;

     r.prototype.findPath=function(t, e, r, n, grid) {
      var s,
      a,
      u,
      h,
      l,
      p = [
      ],
      c = this.allowDiagonal,
      //f = this.dontCrossCorners,
      d = grid.getNodeAt(t, e),
      g = grid.getNodeAt(r, n);
      var stops=[];
      var l=1;
      
      //var e=grid.getNodeAt(endx,endy);
     // stops.push(grid.getNodeAt(r,n));
     // var min=10000000000;
      //var min_dest=grid.getNodeAt(endx,endy);
      
      for(var i=0;i<40;i++){

      for(var j=0;j<60;j++){
      if(grid.isNstopAt(j,i)==0){l++;stops.push(grid.getNodeAt(j,i));}
      }
      }
      var vis=new Map([[d,1]]);
     // alert(stops.length);
      var par =new Map([[d,-1]]);
      var final=[];
      
      var node=d;
      multi2=function(start,vis,stops,grid,diag){
        var prev=[];
      var pr=100000000;
      var node=start;
      for(var i=0;i<stops.length;i++){
        if(!(vis.has(stops[i])) || !(vis.get(stops[i]))){
        var x=bfs(start,stops[i],grid,diag);
        if(x.length<pr){
          pr=x.length;
          prev=x;
          node=stops[i];
        }}
      }
      //alert(node.x);
      vis.set(node,1);
      
      return prev;}
      //var f=0;
      final.push(d);
      //alert(node.x);
      var x1=multi2(node,vis,stops,grid,this.allowDiagonal);
      while(x1.length){
        //alert(1);
       
       for(var i=0;i<x1.length-1;i++){final.push(x1[i]);}
       final.push(x1[i]);
       node=final[final.length-1];
       //vis.set(node,1);
       //alert(node.x);
       x1=multi2(node,vis,stops,grid,this.allowDiagonal);
      }
      
      var ff=bfs(node,g,grid,this.allowDiagonal);
      //alert(node.x);
       for(var i=0;i<ff.length;i++){final.push(ff[i]);}
     
     var e = [
      [final[0].x,
      final[0].y]
    ]; 
    
    for(var i=1;i<final.length;i++){
        e.push([final[i].x,final[i].y]);
       
        
    }
    
    return e;
     
        
      },
      
      
  bfs=  function(start,end,grid,diag){
    var x=[];
      var vi=new Map([[start,1]]);
      var parent=new Map([]);
      var queue=[];
      queue.push(start);
      while(queue.length){
          var t1=queue.shift();
          if(t1==end){

              
              while(t1!=start){
                  x.push(t1);
                  t1=parent.get(t1);
                  
              }
              //x.push(t);
              x.reverse();
              return x;
          }
          var ne=[];
         
          ne = grid.getNeighbors(t1,diag);
          for (var i = 0;i<ne.length; ++i) {
              neighbor = ne[i];

              // skip this neighbor if it has been inspected before
              if (vi.has(neighbor)) {
                  continue;
              }

              queue.push(neighbor);
              vi.set(neighbor,1);
              parent.set(neighbor,t1);
            
          }
      
      }
      
  },
  e.exports = r
},
  
      
        
      {
        '../core/Util': 6
      }
      
    ],
    16: [
      function (t, e) {
        function r(t) {
          t = t || {
          },
          this.allowDiagonal = t.allowDiagonal,
          this.dontCrossCorners = t.dontCrossCorners
        }
        var util = t('../core/Util');
        r.prototype.findPath = function (t, e, r, n, grid) {
          var s,
          a,
          u,
          h,
          l,
          p = [
          ],
          c = this.allowDiagonal,
          f = this.dontCrossCorners,
          d = grid.getNodeAt(t, e),
          g = grid.getNodeAt(r, n);
          var stops=[];
          var l=1;
          //var e=grid.getNodeAt(endx,endy);
          stops.push(grid.getNodeAt(r,n));
         // var min=10000000000;
          //var min_dest=grid.getNodeAt(endx,endy);
          
          for(var i=0;i<40;i++){

          for(var j=0;j<60;j++){
          if(grid.isNstopAt(j,i)==0){l++;stops.push(grid.getNodeAt(j,i));}
          }
          }
          for (p.push(d), d.opened = !0; p.length; ) {
            if (u = p.shift(), u.closed = !0) {
              for(var k=0;k<stops.length;k++){
                
                if(u===stops[k]){return util.backtrace(u);}}
              }
              
            for (s = grid.getNeighbors(u, c, f), h = 0, l = s.length; l > h; ++h) a = s[h],
            a.closed || a.opened || (p.push(a), a.opened = !0, a.parent = u)
          }
          return []
        },
        e.exports = r
      },
      {
        '../core/Util': 6
      }
      
    ],
    
    
    18: [
      function (t, e) {
        function r(t) {
          t = t || {
          },
          this.allowDiagonal = t.allowDiagonal,
         // this.dontCrossCorners = t.dontCrossCorners,
          this.heuristic = t.heuristic || o.manhattan,
          this.weight = t.weight || 1
        }
        var i = t('heap'),
        n = t('../core/Util'),
        o = t('../core/Heuristic');
       // o = t('../core/Heuristic');
       var A= this.heuristic,
       k = this.allowDiagonal,
      // m = this.dontCrossCorners,
       v = this.weight,
       w = Math.abs,
       x = Math.SQRT2;
       r.prototype.findPath = function (t, e, r, o, s) {
        var b=s.getNodeAt(r,o);
         var stops=[];
         stops.push(b);
         for(var i=0;i<40;i++){
           for(var j=0;j<60;j++){
             if(s.isNstopAt(j,i)==0){stops.push(s.getNodeAt(j,i));}
           }
         }
         //alert(stops.length);
         
         var p;
         var final=[];
       
         var PL=10000000;
         var node=b;
         //alert(t);
         for(var i=0;i<stops.length;i++){
           //var astar=new ast;
           var a=(ast(t,e,stops[i].x,stops[i].y,s,this.allowDiagonal,this.heuristic));
           //p=(astar.findPath(t,e,stops[i].x,stops[i].y,s)).length;
           if(a.length<PL){
             final=a;
             PL=a.length;
             node=stops[i];
           }
         }
        // alert(final.length);
         var e = [
          [final[0].x,final[0].y
          ]
        ]; 
        
        for(var i=1;i<final.length;i++){
            e.push([final[i].x,final[i].y]);
           
            
        }
        //alert(e.length);
        return e;
        return final;
         for (y.g = 0, y.f = 0, g.push(y), y.opened = !0; !g.empty(); ) {
           if (a = g.pop(), a.closed = !0){
             for(var i=0;i<stops.length;i++){if(stops[i]===a)return n.backtrace(a);}
             
           } 
           for (u = s.getNeighbors(a, k, m), l = 0, p = u.length; p > l; ++l) h = u[l],
           h.closed || (c = h.x, f = h.y, d = a.g + (0 === c - a.x || 0 === f - a.y ? 1 : x), (!h.opened || d < h.g) && (h.g = d, h.h = h.h || v * A(w(c - r), w(f - o)), h.f = h.g + h.h, h.parent = a, h.opened ? g.updateItem(h)  : (g.push(h), h.opened = !0)))
         }
         return [];
       }
        ast = function (t, e, r, o, grid,diag,heur) {
          var SQRT2=Math.SQRT2;
          for(var x =0 ; x < 40; x++) {
            for(var y = 0; y < 60; y++) {
              grid.getNodeAt(y,x).f=0;
             // grid.getNodeAt(y,x).f=0;
              grid.getNodeAt(y,x).h=0;
              grid.getNodeAt(y,x).g=0;
              //grid[x][y].debug = "";
              grid.getNodeAt(y,x).parent = null;
            }  
          }
          var a,
          u,
          h,
          l,
          p,
          c,
          f,
          d,
          g=[],
          start = grid.getNodeAt(t, e),
          end = grid.getNodeAt(r, o);

          var openList   = [];
        var closedList = [];
        openList.push(start);
     // alert(start.x);
        while(openList.length > 0) {
    
          // Grab the lowest f(x) to process next
          var lowInd = 0;
          for(var i=0; i<openList.length; i++) {
            if(openList[i].f < openList[lowInd].f) { lowInd = i; }
          }
          var currentNode = openList[lowInd];
          //alert(currentNode.x);
          // End case -- result has been found, return the traced path
          if(currentNode===end) {
            var curr = currentNode;
            var ret = [];
            while(curr.parent) {
              ret.push(curr);
              curr = curr.parent;
            }
            ret.push(curr);
            //alert(ret.length);
            return ret.reverse();
          }
    
          // Normal case -- move currentNode from open to closed, process each of its neighbors
          openList.splice(lowInd,1);
          closedList.push(currentNode);
          var neighbors = grid.getNeighbors( currentNode,diag);
    
          for(var i=0; i<neighbors.length;i++) {
           // alert(1);
            var neighbor = neighbors[i];
            if(closedList.findIndex(closedList => closedList === neighbor)!=-1) {
              // not a valid node to process, skip to next neighbor
              continue;
            }
            var x = neighbor.x;
            var y = neighbor.y;
            
            // g score is the shortest distance from start to current node, we need to check if
            //   the path we have arrived at this neighbor is the shortest one we have seen yet
            //var gScore = currentNode.g + 1; // 1 is the distance from a node to it's neighbor
            var gScore =  currentNode.g + ((x -  currentNode.x === 0 || y -  currentNode.y === 0) ? 1 : SQRT2);
            var gScoreIsBest = false;
    
    
            if(openList.findIndex(openList => openList === neighbor)===-1) {
              // This the the first time we have arrived at this node, it must be the best
              // Also, we need to take the h (heuristic) score since we haven't done so yet
    
              gScoreIsBest = true;
              neighbor.h = heur(Math.abs(x-end.x),Math.abs(y-end.y));
              openList.push(neighbor);
            }
            else if(gScore < neighbor.g) {
              // We have already seen the node, but last time it had a worse g (distance from start)
              gScoreIsBest = true;
            }
    
            if(gScoreIsBest) {
              // Found an optimal (so far) path to this node.   Store info on how we got here and
              //  just how good it really is...
              neighbor.parent = currentNode;
              neighbor.g = gScore;
              neighbor.f = neighbor.g + neighbor.h;
              //alert(1);
              //neighbor.debug = "F: " + neighbor.f + "<br />G: " + neighbor.g + "<br />H: " + neighbor.h;
            }
          }
        }
    
        // No result was found -- empty array signifies failure to find path
        return [];
              
        },
        
      
      
        
        e.exports = r
      },
      {
        '../core/Heuristic': 4,
        '../core/Util': 6,
       
        heap: 1
      }
    ],
    
   
    19: [
      function (t, e) {
        
        function r(t) {
          t = t || {
          },
          this.allowDiagonal = t.allowDiagonal
          //this.dontCrossCorners = t.dontCrossCorners
        }
        //var diag=t.allowDiagonal;
      var PL=10000000;
      var p=[];
      var util = t('../core/Util');
     // var nr=new r;

     r.prototype.findPath=function(t, e, r, n, grid) {
      var s,
      a,
      u,
      h,
      l,
      p = [
      ],
      c = this.allowDiagonal,
      f = this.dontCrossCorners,
      d = grid.getNodeAt(t, e),
      g = grid.getNodeAt(r, n);
      var stops=[];
      var l=1;
      
      //var e=grid.getNodeAt(endx,endy);
      stops.push(grid.getNodeAt(r,n));
     // var min=10000000000;
      //var min_dest=grid.getNodeAt(endx,endy);
      
      for(var i=0;i<40;i++){

      for(var j=0;j<60;j++){
      if(grid.isNstopAt(j,i)==0){l++;stops.push(grid.getNodeAt(j,i));}
      }
      }
      var vis=new Map([[d,1]]);
     // alert(stops.length);
      var par =new Map([[d,-1]]);
      var x=algo(d,stops,grid,vis,par,this.allowDiagonal);
      //alert(x[1].length);
      var e = [
        [x[0].x,
        x[0].y]
      ]; 
      
      for(var i=1;i<x.length;i++){
          e.push([x[i].x,x[i].y]);
         
          
      }
      
      return e;
      
    }
    
  
 

  
    bfs3=  function(start,end,grid,diag){
      var x=[];
        var vi=new Map([[start,1]]);
        var parent=new Map([]);
        var queue=[];
        queue.push(start);
        while(queue.length){
            var t1=queue.shift();
            if(t1==end){

                
                while(t1!=start){
                    x.push(t1);
                    t1=parent.get(t1);
                    
                }
                
                return x;
            }
            var ne=[];
           
            ne = grid.getNeighbors(t1,diag);
            for (var i = 0;i<ne.length; ++i) {
                neighbor = ne[i];

                // skip this neighbor if it has been inspected before
                if (vi.has(neighbor)) {
                    continue;
                }

                queue.push(neighbor);
                vi.set(neighbor,1);
                parent.set(neighbor,t1);
              
            }
        
        }
        
    }
    algo=function (start,dest,grid,vis,par,diag){
      var f=0;
      
     // var nr=new r;
      for(var i=0;i<dest.length;i++){
         // alert(vis[dest]);
          if(!(vis.has(dest[i])) || !(vis.get(dest[i]))){
              f=1;
              vis.set(dest[i],1);
              par.set(dest[i],start);
              //parent[dest[i]]=start;
              var a=algo(dest[i],dest,grid,vis,par,diag);

              if(a.length<PL){
                  p=a;
                  PL=p.length;
              }
              vis.set(dest[i],0);
              par.set(dest[i],-1);
          }
      }
      if(f==0){
          var x=[];
          
          //alert(x[0].x);
         // alert((parent.get(start)));
          while(par.get(start)!=-1){
           // var a=new r;

           //x.push(par.get(start));
              var x1=bfs3(par.get(start),start,grid,diag);
              for(var i=0;i<x1.length;i++)x.push(x1[i]);
              start=par.get(start);
              x.push(start);
          }
         // alert(x);
          return x;
          
      }
      else return p;
  },
  e.exports = r
},
  
      
        
      {
        '../core/Util': 6
      }
      
    ],
    20: [
      function (t, e) {
        function r(t) {
          t = t || {
          },
          this.allowDiagonal = t.allowDiagonal,
         // this.dontCrossCorners = t.dontCrossCorners,
          this.heuristic = t.heuristic || o.manhattan,
          this.weight = t.weight || 1
        }
        var i = t('heap'),
        n = t('../core/Util'),
        o = t('../core/Heuristic');
       // o = t('../core/Heuristic');
       var A= this.heuristic,
       k = this.allowDiagonal,
      // m = this.dontCrossCorners,
       v = this.weight,
       w = Math.abs,
       x = Math.SQRT2;
       r.prototype.findPath = function (t, e, r, o, grid) {
         var d=grid.getNodeAt(t,e);
        var b=grid.getNodeAt(r,o);
         var stops=[];
         
         for(var i=0;i<40;i++){
           for(var j=0;j<60;j++){
             if(grid.isNstopAt(j,i)==0){stops.push(grid.getNodeAt(j,i));}
           }
         }
         //alert(stops.length);
         var vis=new Map([[d,1]]);
     // alert(stops.length);
      var par =new Map([[d,-1]]);
      var final=[];
      
      var node=d;
      multi2_astar=function(start,vis,stops,grid,diag,heur){
        var prev=[];
      var pr=100000000;
      var node=start;
      for(var i=0;i<stops.length;i++){
        if(!(vis.has(stops[i])) || !(vis.get(stops[i]))){
        var x=ast(start.x,start.y,stops[i].x,stops[i].y,grid,diag,heur);
        if(x.length<pr){
          pr=x.length;
          prev=x;
          node=stops[i];
        }}
      }
      //alert(node.x);
      vis.set(node,1);
      
      return prev;}
      //var f=0;
      final.push(d);
      //alert(node.x);
      var x1=multi2_astar(node,vis,stops,grid,this.allowDiagonal,this.heuristic);
      while(x1.length){
        //alert(1);
       
       for(var i=0;i<x1.length-1;i++){final.push(x1[i]);}
       final.push(x1[i]);
       node=final[final.length-1];
       //vis.set(node,1);
       //alert(node.x);
       x1=multi2_astar(node,vis,stops,grid,this.allowDiagonal,this.heuristic);
      }
      
      var ff=ast(node.x,node.y,b.x,b.y,grid,this.allowDiagonal,this.heuristic);
      //alert(node.x);
       for(var i=0;i<ff.length;i++){final.push(ff[i]);}
     
     var e = [
      [final[0].x,
      final[0].y]
    ]; 
    
    for(var i=1;i<final.length;i++){
        e.push([final[i].x,final[i].y]);
       
        
    }
    
    return e;
  },
         
         
        ast = function (t, e, r, o, grid,diag,heur) {
          var SQRT2=Math.SQRT2;
          for(var x =0 ; x < 40; x++) {
            for(var y = 0; y < 60; y++) {
              grid.getNodeAt(y,x).f=0;
             // grid.getNodeAt(y,x).f=0;
              grid.getNodeAt(y,x).h=0;
              grid.getNodeAt(y,x).g=0;
              //grid[x][y].debug = "";
              grid.getNodeAt(y,x).parent = null;
            }  
          }
          var a,
          u,
          h,
          l,
          p,
          c,
          f,
          d,
          g=[],
          start = grid.getNodeAt(t, e),
          end = grid.getNodeAt(r, o);

          var openList   = [];
        var closedList = [];
        openList.push(start);
     // alert(start.x);
        while(openList.length > 0) {
    
          // Grab the lowest f(x) to process next
          var lowInd = 0;
          for(var i=0; i<openList.length; i++) {
            if(openList[i].f < openList[lowInd].f) { lowInd = i; }
          }
          var currentNode = openList[lowInd];
          //alert(currentNode.x);
          // End case -- result has been found, return the traced path
          if(currentNode===end) {
            var curr = currentNode;
            var ret = [];
            while(curr.parent) {
              ret.push(curr);
              curr = curr.parent;
            }
            ret.push(curr);
            //alert(ret.length);
            return ret.reverse();
          }
    
          // Normal case -- move currentNode from open to closed, process each of its neighbors
          openList.splice(lowInd,1);
          closedList.push(currentNode);
          var neighbors = grid.getNeighbors( currentNode,diag);
    
          for(var i=0; i<neighbors.length;i++) {
           // alert(1);
            var neighbor = neighbors[i];
            if(closedList.findIndex(closedList => closedList === neighbor)!=-1) {
              // not a valid node to process, skip to next neighbor
              continue;
            }
            var x = neighbor.x;
            var y = neighbor.y;
            
            // g score is the shortest distance from start to current node, we need to check if
            //   the path we have arrived at this neighbor is the shortest one we have seen yet
            //var gScore = currentNode.g + 1; // 1 is the distance from a node to it's neighbor
            var gScore =  currentNode.g + ((x -  currentNode.x === 0 || y -  currentNode.y === 0) ? 1 : SQRT2);
            var gScoreIsBest = false;
    
    
            if(openList.findIndex(openList => openList === neighbor)===-1) {
              // This the the first time we have arrived at this node, it must be the best
              // Also, we need to take the h (heuristic) score since we haven't done so yet
    
              gScoreIsBest = true;
              neighbor.h = heur(Math.abs(x-end.x),Math.abs(y-end.y));
              openList.push(neighbor);
            }
            else if(gScore < neighbor.g) {
              // We have already seen the node, but last time it had a worse g (distance from start)
              gScoreIsBest = true;
            }
    
            if(gScoreIsBest) {
              // Found an optimal (so far) path to this node.   Store info on how we got here and
              //  just how good it really is...
              neighbor.parent = currentNode;
              neighbor.g = gScore;
              neighbor.f = neighbor.g + neighbor.h;
              //alert(1);
              //neighbor.debug = "F: " + neighbor.f + "<br />G: " + neighbor.g + "<br />H: " + neighbor.h;
            }
          }
        }
    
        // No result was found -- empty array signifies failure to find path
        return [];
              
        },
        
      
      
        
        e.exports = r
      },
      {
        '../core/Heuristic': 4,
        '../core/Util': 6,
       
        heap: 1
      }
      
    ],
    
    
    21: [
      function (t, e) {
        e.exports = {
          Heap: t('heap'),
          Node: t('./core/Node'),
          Grid: t('./core/Grid'),
          Util: t('./core/Util'),
          Heuristic: t('./core/Heuristic'),
          AStarFinder: t('./finders/AStarFinder'),
         
          BreadthFirstFinder: t('./finders/BreadthFirstFinder'),
          DijkstraFinder: t('./finders/DijkstraFinder'),
          BiAStarFinder: t('./finders/BiAStarFinder'),
        
          BiBreadthFirstFinder: t('./finders/BiBreadthFirstFinder'),
          BiDijkstraFinder: t('./finders/BiDijkstraFinder'),
         closest_destination_astar: t('./finders/closest_destination_astar'),
         closest_destination_bfs: t('./finders/closest_destination_bfs'),
          multiple_stop_bfs: t('./finders/multiple_stop_bfs'),
          multiple_visitation_bfs: t('./finders/multiple_visitation_bfs'),
         
          multiple_stop_astar: t('./finders/multiple_stop_astar'),
          multiple_visitation_astar: t('./finders/multiple_visitation_astar'),
          
        }
      },
      {
        './core/Grid': 3,
        './core/Heuristic': 4,
        './core/Node': 5,
        './core/Util': 6,
        './finders/AStarFinder': 7,
        './finders/multiple_stop_astar': 8,
        './finders/BiAStarFinder': 9,
         './finders/BiBreadthFirstFinder': 11,
        './finders/BiDijkstraFinder': 12,
        './finders/BreadthFirstFinder': 13,
        './finders/DijkstraFinder': 14,
        './finders/closest_destination_astar': 18,
        './finders/multiple_stop_bfs': 19,
       
        './finders/closest_destination_bfs': 16,
        './finders/multiple_visitation_bfs': 15,
        './finders/multiple_visitation_astar': 20,
        

        
        heap: 1
      }
    ]
  }, {
  }, [
    21
  ]) (21)
});
