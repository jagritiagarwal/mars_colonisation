!function (t) {
  if ('object' == typeof exports && 'undefined' != typeof module) module.exports = t();
   else if ('function' == typeof define && define.amd) define([], t);
   else {
    var e;
    'undefined' != typeof window ? e = window : 'undefined' != typeof global ? e = global : 'undefined' != typeof self && (e = self),
    e.PF = t()
  }
}(function () {
  return function t(e, r, i) {
    function n(s, a) {
      if (!r[s]) {
        if (!e[s]) {
          var u = 'function' == typeof require && require;
          if (!a && u) return u(s, !0);
          if (o) return o(s, !0);
          var h = new Error('Cannot find module \'' + s + '\'');
          throw h.code = 'MODULE_NOT_FOUND',
          h
        }
        var l = r[s] = {
          exports: {
          }
        };
        e[s][0].call(l.exports, function (t) {
          var r = e[s][1][t];
          return n(r ? r : t)
        }, l, l.exports, t, e, r, i)
      }
      return r[s].exports
    }
    for (var o = 'function' == typeof require && require, s = 0; s < i.length; s++) n(i[s]);
    return n
  }({
    1: [
      function (t, e) {
        e.exports = t('./lib/heap')
      },
      {
        './lib/heap': 2
      }
    ],
    2: [
      function (t, e) {
        !function () {
          var t,
          r,
          i,
          n,
          o,
          s,
          a,
          u,
          h,
          l,
          p,
          c,
          f,
          d,
          g;
          i = Math.floor,
          l = Math.min,
          r = function (t, e) {
            return e > t ? - 1 : t > e ? 1 : 0
          },
          h = function (t, e, n, o, s) {
            var a;
            if (null == n && (n = 0), null == s && (s = r), 0 > n) throw new Error('lo must be non-negative');
            for (null == o && (o = t.length); o > n; ) a = i((n + o) / 2),
            s(e, t[a]) < 0 ? o = a : n = a + 1;
            return [].splice.apply(t, [
              n,
              n - n
            ].concat(e)),
            e
          },
          s = function (t, e, i) {
            return null == i && (i = r),
            t.push(e),
            d(t, 0, t.length - 1, i)
          },
          o = function (t, e) {
            var i,
            n;
            return null == e && (e = r),
            i = t.pop(),
            t.length ? (n = t[0], t[0] = i, g(t, 0, e))  : n = i,
            n
          },
          u = function (t, e, i) {
            var n;
            return null == i && (i = r),
            n = t[0],
            t[0] = e,
            g(t, 0, i),
            n
          },
          a = function (t, e, i) {
            var n;
            return null == i && (i = r),
            t.length && i(t[0], e) < 0 && (n = [
              t[0],
              e
            ], e = n[0], t[0] = n[1], g(t, 0, i)),
            e
          },
          n = function (t, e) {
            var n,
            o,
            s,
            a,
            u,
            h;
            for (null == e && (e = r), a = function () {
              h = [
              ];
              for (var e = 0, r = i(t.length / 2); r >= 0 ? r > e : e > r; r >= 0 ? e++ : e--) h.push(e);
              return h
            }.apply(this).reverse(), u = [
            ], o = 0, s = a.length; s > o; o++) n = a[o],
            u.push(g(t, n, e));
            return u
          },
          f = function (t, e, i) {
            var n;
            return null == i && (i = r),
            n = t.indexOf(e),
            - 1 !== n ? (d(t, 0, n, i), g(t, n, i))  : void 0
          },
          p = function (t, e, i) {
            var o,
            s,
            u,
            h,
            l;
            if (null == i && (i = r), s = t.slice(0, e), !s.length) return s;
            for (n(s, i), l = t.slice(e), u = 0, h = l.length; h > u; u++) o = l[u],
            a(s, o, i);
            return s.sort(i).reverse()
          },
          c = function (t, e, i) {
            var s,
            a,
            u,
            p,
            c,
            f,
            d,
            g,
            y,
            b;
            if (null == i && (i = r), 10 * e <= t.length) {
              if (p = t.slice(0, e).sort(i), !p.length) return p;
              for (u = p[p.length - 1], g = t.slice(e), c = 0, d = g.length; d > c; c++) s = g[c],
              i(s, u) < 0 && (h(p, s, 0, null, i), p.pop(), u = p[p.length - 1]);
              return p
            }
            for (n(t, i), b = [
            ], a = f = 0, y = l(e, t.length); y >= 0 ? y > f : f > y; a = y >= 0 ? ++f : --f) b.push(o(t, i));
            return b
          },
          d = function (t, e, i, n) {
            var o,
            s,
            a;
            for (null == n && (n = r), o = t[i]; i > e && (a = i - 1 >> 1, s = t[a], n(o, s) < 0); ) t[i] = s,
            i = a;
            return t[i] = o
          },
          g = function (t, e, i) {
            var n,
            o,
            s,
            a,
            u;
            for (null == i && (i = r), o = t.length, u = e, s = t[e], n = 2 * e + 1; o > n; ) a = n + 1,
            o > a && !(i(t[n], t[a]) < 0) && (n = a),
            t[e] = t[n],
            e = n,
            n = 2 * e + 1;
            return t[e] = s,
            d(t, u, e, i)
          },
          t = function () {
            function t(t) {
              this.cmp = null != t ? t : r,
              this.nodes = [
              ]
            }
            return t.push = s,
            t.pop = o,
            t.replace = u,
            t.pushpop = a,
            t.heapify = n,
            t.nlargest = p,
            t.nsmallest = c,
            t.prototype.push = function (t) {
              return s(this.nodes, t, this.cmp)
            },
            t.prototype.pop = function () {
              return o(this.nodes, this.cmp)
            },
            t.prototype.peek = function () {
              return this.nodes[0]
            },
            t.prototype.contains = function (t) {
              return - 1 !== this.nodes.indexOf(t)
            },
            t.prototype.replace = function (t) {
              return u(this.nodes, t, this.cmp)
            },
            t.prototype.pushpop = function (t) {
              return a(this.nodes, t, this.cmp)
            },
            t.prototype.heapify = function () {
              return n(this.nodes, this.cmp)
            },
            t.prototype.updateItem = function (t) {
              return f(this.nodes, t, this.cmp)
            },
            t.prototype.clear = function () {
              return this.nodes = [
              ]
            },
            t.prototype.empty = function () {
              return 0 === this.nodes.length
            },
            t.prototype.size = function () {
              return this.nodes.length
            },
            t.prototype.clone = function () {
              var e;
              return e = new t,
              e.nodes = this.nodes.slice(0),
              e
            },
            t.prototype.toArray = function () {
              return this.nodes.slice(0)
            },
            t.prototype.insert = t.prototype.push,
            t.prototype.remove = t.prototype.pop,
            t.prototype.top = t.prototype.peek,
            t.prototype.front = t.prototype.peek,
            t.prototype.has = t.prototype.contains,
            t.prototype.copy = t.prototype.clone,
            t
          }(),
          ('undefined' != typeof e && null !== e ? e.exports : void 0) ? e.exports = t : window.Heap = t
        }.call(this)
      },
      {
      }
    ],
    3: [
      function (t, e) {
        function r(t, e, r,stop) {
          this.width = t,
          this.height = e,
          this.nodes = this._buildNodes(t, e, r)
        }
        var i = t('./Node');
        r.prototype._buildNodes = function (t, e, r) {
          var n,
          o,
          s = new Array(e);
          for (n = 0; e > n; ++n) for (s[n] = new Array(t), o = 0; t > o; ++o) s[n][o] = new i(o, n);
          if (void 0 === r) return s;
          if (r.length !== e || r[0].length !== t) throw new Error('Matrix size does not fit');
          for (n = 0; e > n; ++n) for (o = 0; t > o; ++o) r[n][o] && (s[n][o].walkable = !1) ;
          return s
        },
        r.prototype.getNodeAt = function (t, e) {
          return this.nodes[e][t]
        },
        r.prototype.isWalkableAt = function (t, e) {
          return this.isInside(t, e) && this.nodes[e][t].walkable
        },
        r.prototype.isNstopAt = function (t, e) {
          return this.isInside(t, e) && this.nodes[e][t].Nstop
        },
        r.prototype.isInside = function (t, e) {
          return t >= 0 && t < this.width && e >= 0 && e < this.height
        },
        r.prototype.setWalkableAt = function (t, e,r) {
          this.nodes[e][t].walkable = r
        },
        r.prototype.setNstopAt = function (t, e,r) {
          this.nodes[e][t].Nstop = r
        },
        r.prototype.getNeighbors = function (t, e, r) {
          var i = t.x,
          n = t.y,
          o = [
          ],
          s = !1,
          a = !1,
          u = !1,
          h = !1,
          l = !1,
          p = !1,
          c = !1,
          f = !1,
          d = this.nodes;
          return this.isWalkableAt(i, n - 1) && (o.push(d[n - 1][i]), s = !0),
          this.isWalkableAt(i + 1, n) && (o.push(d[n][i + 1]), u = !0),
          this.isWalkableAt(i, n + 1) && (o.push(d[n + 1][i]), l = !0),
          this.isWalkableAt(i - 1, n) && (o.push(d[n][i - 1]), c = !0),
          e ? (r ? (a = c && s, h = s && u, p = u && l, f = l && c)  : (a = c || s, h = s || u, p = u || l, f = l || c), a && this.isWalkableAt(i - 1, n - 1) && o.push(d[n - 1][i - 1]), h && this.isWalkableAt(i + 1, n - 1) && o.push(d[n - 1][i + 1]), p && this.isWalkableAt(i + 1, n + 1) && o.push(d[n + 1][i + 1]), f && this.isWalkableAt(i - 1, n + 1) && o.push(d[n + 1][i - 1]), o)  : o
        },
        r.prototype.clone = function () {
          var t,
          e,
          n = this.width,
          o = this.height,
          s = this.nodes,
          a = new r(n, o),
          u = new Array(o);
          for (t = 0; o > t; ++t) for (u[t] = new Array(n), e = 0; n > e; ++e) u[t][e] = new i(e, t, s[t][e].walkable,s[t][e].Nstop);
          return a.nodes = u,
          a
        },
        e.exports = r
      },
      {
        './Node': 5
      }
    ],
    4: [
      function (t, e) {
        e.exports = {
          manhattan: function (t, e) {
            return t + e
          },
          euclidean: function (t, e) {
            return Math.sqrt(t * t + e * e)
          },
          octile: function (t, e) {
            var r = Math.SQRT2 - 1;
            return e > t ? r * t + e : r * e + t
          },
          chebyshev: function (t, e) {
            return Math.max(t, e)
          }
        }
      },
      {
      }
    ],
    5: [
      function (t, e) {
        function r(t, e, r,ns) {
          this.x = t,
          this.y = e,
          this.walkable = void 0 === r ? !0 : r
          this.Nstop = void 0 === ns ? !0 : ns
        }
        e.exports = r
      },
      {
      }
    ],
    6: [
      function (t, e, r) {
        function i(t) {
          for (var e = [
            [t.x,
            t.y]
          ]; t.parent; ) t = t.parent,
          e.push([t.x,
          t.y]);
          return e.reverse()
        }
        function n(t, e) {
          var r = i(t),
          n = i(e);
          return r.concat(n.reverse())
        }
        function o(t) {
          var e,
          r,
          i,
          n,
          o,
          s = 0;
          for (e = 1; e < t.length; ++e) r = t[e - 1],
          i = t[e],
          n = r[0] - i[0],
          o = r[1] - i[1],
          s += Math.sqrt(n * n + o * o);
          return s
        }
        function s(t, e, r, i) {
          var n,
          o,
          s,
          a,
          u,
          h,
          l = Math.abs,
          p = [
          ];
          for (s = l(r - t), a = l(i - e), n = r > t ? 1 : - 1, o = i > e ? 1 : - 1, u = s - a; ; ) {
            if (p.push([t,
            e]), t === r && e === i) break;
            h = 2 * u,
            h > - a && (u -= a, t += n),
            s > h && (u += s, e += o)
          }
          return p
        }
        function a(t) {
          var e,
          r,
          i,
          n,
          o,
          a,
          u = [
          ],
          h = t.length;
          if (2 > h) return u;
          for (o = 0; h - 1 > o; ++o) for (e = t[o], r = t[o + 1], i = s(e[0], e[1], r[0], r[1]), n = i.length, a = 0; n - 1 > a; ++a) u.push(i[a]);
          return u.push(t[h - 1]),
          u
        }
        function u(t, e) {
          var r,
          i,
          n,
          o,
          a,
          u,
          h,
          l,
          p,
          c,
          f,
          d,
          g,
          y = e.length,
          b = e[0][0],
          A = e[0][1],
          k = e[y - 1][0],
          m = e[y - 1][1];
          for (r = b, i = A, a = e[1][0], u = e[1][1], h = [
            [r,
            i]
          ], l = 2; y > l; ++l) {
            for (c = e[l], n = c[0], o = c[1], f = s(r, i, n, o), g = !1, p = 1; p < f.length; ++p) if (d = f[p], !t.isWalkableAt(d[0], d[1])) {
              g = !0,
              h.push([a,
              u]),
              r = a,
              i = u;
              break
            }
            g || (a = n, u = o)
          }
          return h.push([k,
          m]),
          h
        }
        function h(t) {
          if (t.length < 3) return t;
          var e,
          r,
          i,
          n,
          o,
          s,
          a = [
          ],
          u = t[0][0],
          h = t[0][1],
          l = t[1][0],
          p = t[1][1],
          c = l - u,
          f = p - h;
          for (o = Math.sqrt(c * c + f * f), c /= o, f /= o, a.push([u,
          h]), s = 2; s < t.length; s++) e = l,
          r = p,
          i = c,
          n = f,
          l = t[s][0],
          p = t[s][1],
          c = l - e,
          f = p - r,
          o = Math.sqrt(c * c + f * f),
          c /= o,
          f /= o,
          (c !== i || f !== n) && a.push([e,
          r]);
          return a.push([l,
          p]),
          a
        }
        r.backtrace = i,
        r.biBacktrace = n,
        r.pathLength = o,
        r.interpolate = s,
        r.expandPath = a,
        r.smoothenPath = u,
        r.compressPath = h
      },
      {
      }
    ],
    7: [
      function (t, e) {
        function r(t) {
          t = t || {
          },
          this.allowDiagonal = t.allowDiagonal,
          this.dontCrossCorners = t.dontCrossCorners,
          this.heuristic = t.heuristic || o.manhattan,
          this.weight = t.weight || 1
        }
        var i = t('heap'),
        n = t('../core/Util'),
        o = t('../core/Heuristic');
        r.prototype.findPath = function (t, e, r, o, s) {
          var a,
          u,
          h,
          l,
          p,
          c,
          f,
          d,
          g = new i(function (t, e) {
            return t.f - e.f
          }),
          y = s.getNodeAt(t, e),
          b = s.getNodeAt(r, o),
          A = this.heuristic,
          k = this.allowDiagonal,
          m = this.dontCrossCorners,
          v = this.weight,
          w = Math.abs,
          x = Math.SQRT2;
          for (y.g = 0, y.f = 0, g.push(y), y.opened = !0; !g.empty(); ) {
            if (a = g.pop(), a.closed = !0, a === b) return n.backtrace(b);
            for (u = s.getNeighbors(a, k, m), l = 0, p = u.length; p > l; ++l) h = u[l],
            h.closed || (c = h.x, f = h.y, d = a.g + (0 === c - a.x || 0 === f - a.y ? 1 : x), (!h.opened || d < h.g) && (h.g = d, h.h = h.h || v * A(w(c - r), w(f - o)), h.f = h.g + h.h, h.parent = a, h.opened ? g.updateItem(h)  : (g.push(h), h.opened = !0)))
          }
          return []
        },
        e.exports = r
      },
      {
        '../core/Heuristic': 4,
        '../core/Util': 6,
        heap: 1
      }
    ],
    8: [
      function (t, e) {
        function r(t) {
          i.call(this, t);
          var e = this.heuristic;
          this.heuristic = function (t, r) {
            return 1000000 * e(t, r)
          }
        }
        var i = t('./AStarFinder');
        r.prototype = new i,
        r.prototype.constructor = r,
        e.exports = r
      },
      {
        './AStarFinder': 7
      }
    ],
    9: [
      function (t, e) {
        function r(t) {
          t = t || {
          },
          this.allowDiagonal = t.allowDiagonal,
          this.dontCrossCorners = t.dontCrossCorners,
          this.heuristic = t.heuristic || o.manhattan,
          this.weight = t.weight || 1
        }
        var i = t('heap'),
        n = t('../core/Util'),
        o = t('../core/Heuristic');
        r.prototype.findPath = function (t, e, r, o, s) {
          var a,
          u,
          h,
          l,
          p,
          c,
          f,
          d,
          g = function (t, e) {
            return t.f - e.f
          },
          y = new i(g),
          b = new i(g),
          A = s.getNodeAt(t, e),
          k = s.getNodeAt(r, o),
          m = this.heuristic,
          v = this.allowDiagonal,
          w = this.dontCrossCorners,
          x = this.weight,
          F = Math.abs,
          W = Math.SQRT2,
          N = 1,
          C = 2;
          for (A.g = 0, A.f = 0, y.push(A), A.opened = N, k.g = 0, k.f = 0, b.push(k), k.opened = C; !y.empty() && !b.empty(); ) {
            for (a = y.pop(), a.closed = !0, u = s.getNeighbors(a, v, w), l = 0, p = u.length; p > l; ++l) if (h = u[l], !h.closed) {
              if (h.opened === C) return n.biBacktrace(a, h);
              c = h.x,
              f = h.y,
              d = a.g + (0 === c - a.x || 0 === f - a.y ? 1 : W),
              (!h.opened || d < h.g) && (h.g = d, h.h = h.h || x * m(F(c - r), F(f - o)), h.f = h.g + h.h, h.parent = a, h.opened ? y.updateItem(h)  : (y.push(h), h.opened = N))
            }
            for (a = b.pop(), a.closed = !0, u = s.getNeighbors(a, v, w), l = 0, p = u.length; p > l; ++l) if (h = u[l], !h.closed) {
              if (h.opened === N) return n.biBacktrace(h, a);
              c = h.x,
              f = h.y,
              d = a.g + (0 === c - a.x || 0 === f - a.y ? 1 : W),
              (!h.opened || d < h.g) && (h.g = d, h.h = h.h || x * m(F(c - t), F(f - e)), h.f = h.g + h.h, h.parent = a, h.opened ? b.updateItem(h)  : (b.push(h), h.opened = C))
            }
          }
          return []
        },
        e.exports = r
      },
      {
        '../core/Heuristic': 4,
        '../core/Util': 6,
        heap: 1
      }
    ],
    10: [
      function (t, e) {
        function r(t) {
          i.call(this, t);
          var e = this.heuristic;
          this.heuristic = function (t, r) {
            return 1000000 * e(t, r)
          }
        }
        var i = t('./BiAStarFinder');
        r.prototype = new i,
        r.prototype.constructor = r,
        e.exports = r
      },
      {
        './BiAStarFinder': 9
      }
    ],
    11: [
      function (t, e) {
        function r(t) {
          t = t || {
          },
          this.allowDiagonal = t.allowDiagonal,
          this.dontCrossCorners = t.dontCrossCorners
        }
        var i = t('../core/Util');
        r.prototype.findPath = function (t, e, r, n, o) {
          var s,
          a,
          u,
          h,
          l,
          p = o.getNodeAt(t, e),
          c = o.getNodeAt(r, n),
          f = [
          ],
          d = [
          ],
          g = this.allowDiagonal,
          y = this.dontCrossCorners,
          b = 0,
          A = 1;
          for (f.push(p), p.opened = !0, p.by = b, d.push(c), c.opened = !0, c.by = A; f.length && d.length; ) {
            for (u = f.shift(), u.closed = !0, s = o.getNeighbors(u, g, y), h = 0, l = s.length; l > h; ++h) if (a = s[h], !a.closed) if (a.opened) {
              if (a.by === A) return i.biBacktrace(u, a)
            } else f.push(a),
            a.parent = u,
            a.opened = !0,
            a.by = b;
            for (u = d.shift(), u.closed = !0, s = o.getNeighbors(u, g, y), h = 0, l = s.length; l > h; ++h) if (a = s[h], !a.closed) if (a.opened) {
              if (a.by === b) return i.biBacktrace(a, u)
            } else d.push(a),
            a.parent = u,
            a.opened = !0,
            a.by = A
          }
          return []
        },
        e.exports = r
      },
      {
        '../core/Util': 6
      }
    ],
    12: [
      function (t, e) {
        function r(t) {
          i.call(this, t),
          this.heuristic = function () {
            return 0
          }
        }
        var i = t('./BiAStarFinder');
        r.prototype = new i,
        r.prototype.constructor = r,
        e.exports = r
      },
      {
        './BiAStarFinder': 9
      }
    ],
    13: [
      function (t, e) {
        function r(t) {
          t = t || {
          },
          this.allowDiagonal = t.allowDiagonal,
          this.dontCrossCorners = t.dontCrossCorners
        }
        var i = t('../core/Util');
        r.prototype.findPath = function (t, e, r, n, o) {
          var s,
          a,
          u,
          h,
          l,
          p = [
          ],
          c = this.allowDiagonal,
          f = this.dontCrossCorners,
          d = o.getNodeAt(t, e),
          g = o.getNodeAt(r, n);

          for (p.push(d), d.opened = !0; p.length; ) {
            if (u = p.shift(), u.closed = !0, u === g) return i.backtrace(g);
            for (s = o.getNeighbors(u, c, f), h = 0, l = s.length; l > h; ++h) a = s[h],
            a.closed || a.opened || (p.push(a), a.opened = !0, a.parent = u)
          }
          return []
        },
        e.exports = r
      },
      {
        '../core/Util': 6
      }
    ],
    14: [
      function (t, e) {
        function r(t) {
          i.call(this, t),
          this.heuristic = function () {
            return 0
          }
        }
        var i = t('./AStarFinder');
        r.prototype = new i,
        r.prototype.constructor = r,
        e.exports = r
      },
      {
        './AStarFinder': 7
      }
    ],
    15: [
      function (t, e) {
        
        function r(t) {
          t = t || {
          },
          this.allowDiagonal = t.allowDiagonal,
          this.dontCrossCorners = t.dontCrossCorners
        }
        //var diag=t.allowDiagonal;
      var PL=10000000;
      var p=[];
      var util = t('../core/Util');
     // var nr=new r;

     r.prototype.findPath=function(t, e, r, n, grid) {
      var s,
      a,
      u,
      h,
      l,
      p = [
      ],
      c = this.allowDiagonal,
      f = this.dontCrossCorners,
      d = grid.getNodeAt(t, e),
      g = grid.getNodeAt(r, n);
      var stops=[];
      var l=1;
      
      //var e=grid.getNodeAt(endx,endy);
     // stops.push(grid.getNodeAt(r,n));
     // var min=10000000000;
      //var min_dest=grid.getNodeAt(endx,endy);
      
      for(var i=0;i<40;i++){

      for(var j=0;j<60;j++){
      if(grid.isNstopAt(j,i)==0){l++;stops.push(grid.getNodeAt(j,i));}
      }
      }
      var vis=new Map([[d,1]]);
     // alert(stops.length);
      var par =new Map([[d,-1]]);
      var final=[];
      
      var node=d;
      multi2=function(start,vis,stops){
        var prev=[];
      var pr=100000000;
      var node=start;
      for(var i=0;i<stops.length;i++){
        if(!(vis.has(stops[i])) || !(vis.get(stops[i]))){
        var x=bfs(start,stops[i],grid);
        if(x.length<pr){
          pr=x.length;
          prev=x;
          node=stops[i];
        }}
      }
      //alert(node.x);
      vis.set(node,1);
      
      return prev;}
      //var f=0;
      final.push(d);
      //alert(node.x);
      var x1=multi2(node,vis,stops);
      while(x1.length){
        //alert(1);
       
       for(var i=0;i<x1.length-1;i++){grid.setWalkableAt(x1[i].y,x1[i].x,0,1);final.push(x1[i]);}
       final.push(x1[i]);
       node=final[final.length-1];
       //vis.set(node,1);
       //alert(node.x);
       x1=multi2(node,vis,stops);
      }
      
      var ff=bfs(node,g,grid);
      //alert(node.x);
       for(var i=0;i<ff.length;i++){final.push(ff[i]);}
      
     // final.push(d);
     /* vis.set(node,1);
      //for(var i=0;i<prev.length;i++)final.push(prev[i]);
      for(var i=0;i<prev.length;i++)final.push(prev[i]);
      for(var i=0;i<stops.length;i++){
        if(!(vis.has(stops[i])) || !(vis.get(stops[i]))){
          vis.set(stops[i],1);
          //node=stops[i];
          //final.push(stops[i]);}
        var prev=[];
        var pr=10000000;
        for(var j=0;j<stops.length;j++){
          if(i!=j && (!(vis.has(stops[j])) || !(vis.get(stops[j])))){
            var x=bfs(stops[i],stops[j],grid);
            if(x.length<pr){
              
              //if(prev.length()>0 && final.length>0)final.pop();
              pr=x.length;
              prev=x;
              node=stops[j];
            }
          }

        
        }
        vis.set(node,1);
        for(var i=0;i<prev.length;i++)final.push(prev[i]);
      }}
      var x=bfs(node,g,grid);
      for(var i=0;i<x.length;i++)final.push(x[i]);
      //alert(final.length);
     // final.push(d);*/
      for(var i=0;i<final.length-1;i++){
        final[i].parent=final[i+1];
        alert(final[i].y);
      }
      alert(final[i].y);
      final[i].parent=0;
      return util.backtrace(final[0]);
        
      },
      
      
  bfs=  function(start,end,grid){
    var x=[];
      var vi=new Map([[start,1]]);
      var parent=new Map([]);
      var queue=[];
      queue.push(start);
      while(queue.length){
          var t1=queue.shift();
          if(t1==end){

              
              while(t1!=start){
                  x.push(t1);
                  t1=parent.get(t1);
                  
              }
              //x.push(t);
              x.reverse();
              return x;
          }
          var ne=[];
         
          ne = grid.getNeighbors(t1,this.allowDiagonal,this.dontCrossCorners);
          for (var i = 0;i<ne.length; ++i) {
              neighbor = ne[i];

              // skip this neighbor if it has been inspected before
              if (vi.has(neighbor)) {
                  continue;
              }

              queue.push(neighbor);
              vi.set(neighbor,1);
              parent.set(neighbor,t1);
            
          }
      
      }
      
  },
  e.exports = r
},
  
      
        
      {
        '../core/Util': 6
      }
      
    ],
    16: [
      function (t, e) {
        function r(t) {
          t = t || {
          },
          this.allowDiagonal = t.allowDiagonal,
          this.dontCrossCorners = t.dontCrossCorners
        }
        var util = t('../core/Util');
        r.prototype.findPath = function (t, e, r, n, grid) {
          var s,
          a,
          u,
          h,
          l,
          p = [
          ],
          c = this.allowDiagonal,
          f = this.dontCrossCorners,
          d = grid.getNodeAt(t, e),
          g = grid.getNodeAt(r, n);
          var stops=[];
          var l=1;
          //var e=grid.getNodeAt(endx,endy);
          stops.push(grid.getNodeAt(r,n));
         // var min=10000000000;
          //var min_dest=grid.getNodeAt(endx,endy);
          
          for(var i=0;i<40;i++){

          for(var j=0;j<60;j++){
          if(grid.isNstopAt(j,i)==0){l++;stops.push(grid.getNodeAt(j,i));}
          }
          }
          for (p.push(d), d.opened = !0; p.length; ) {
            if (u = p.shift(), u.closed = !0) {
              for(var k=0;k<stops.length;k++){
                
                if(u===stops[k]){return util.backtrace(u);}}
              }
              
            for (s = grid.getNeighbors(u, c, f), h = 0, l = s.length; l > h; ++h) a = s[h],
            a.closed || a.opened || (p.push(a), a.opened = !0, a.parent = u)
          }
          return []
        },
        e.exports = r
      },
      {
        '../core/Util': 6
      }
      /*function (t, e) {
        function r(t) {
          t = t || {
          },
          this.allowDiagonal = t.allowDiagonal,
          this.dontCrossCorners = t.dontCrossCorners
        }
        var i = t('../core/Util');
        var bfs=t('./BreadthFirstFinder');
                r.prototype.findPath = function (startx,starty,endx,endy, grid) {
        var stops=[];
        var l=1;
        var e=grid.getNodeAt(endx,endy);
        stops.push(grid.getNodeAt(endx,endy));
        var min=10000000000;
        var min_dest=grid.getNodeAt(endx,endy);
        start=grid.getNodeAt(startx,starty);
        for(var i=0;i<40;i++){
        for(var j=0;j<60;j++){
        if(grid.isNstopAt(j,i)==0){l++;stops.push(grid.getNodeAt(j,i));}
        }
        }
        var x=[];
        for(var k=0;k<l;k++){
          var y=new bfs;
          x=y.findPath(startx,starty,stops[k].x,stops[k].y,grid);
        if(min>x.length){
        min=x.length;
        min_dest=stops[k];
        }
        }
       
        //alert(e.x,e.y,min_dest.x,min_dest.y);
        
        return i.backtrace(min_dest);
        }
        e.exports = r
       },
       {
        '../core/Util': 6,
        './BreadthFirstFinder': 13
       }*/
    ],
    17: [
      function (t, e) {
        function r(t) {
          n.call(this, t),
          t = t || {
          },
          this.heuristic = t.heuristic || i.manhattan
        }
        var i = t('../core/Heuristic'),
        n = t('./JumpPointFinder');
        r.prototype = new n,
        r.prototype.constructor = r,
        r.prototype._jump = function (t, e, r, i) {
          var n = this.grid,
          o = t - r,
          s = e - i;
          if (!n.isWalkableAt(t, e)) return null;
          if (this.trackJumpRecursion === !0 && (n.getNodeAt(t, e).tested = !0), n.getNodeAt(t, e) === this.endNode) return [t,
          e];
          if (0 !== o) {
            if (n.isWalkableAt(t, e - 1) && !n.isWalkableAt(t - o, e - 1) || n.isWalkableAt(t, e + 1) && !n.isWalkableAt(t - o, e + 1)) return [t,
            e]
          } else {
            if (0 === s) throw new Error('Only horizontal and vertical movements are allowed');
            if (n.isWalkableAt(t - 1, e) && !n.isWalkableAt(t - 1, e - s) || n.isWalkableAt(t + 1, e) && !n.isWalkableAt(t + 1, e - s)) return [t,
            e];
            if (this._jump(t + 1, e, t, e) || this._jump(t - 1, e, t, e)) return [t,
            e]
          }
          return this._jump(t + o, e + s, t, e)
        },
        r.prototype._findNeighbors = function (t) {
          var e,
          r,
          i,
          n,
          o,
          s,
          a,
          u,
          h = t.parent,
          l = t.x,
          p = t.y,
          c = this.grid,
          f = [
          ];
          if (h) e = h.x,
          r = h.y,
          i = (l - e) / Math.max(Math.abs(l - e), 1),
          n = (p - r) / Math.max(Math.abs(p - r), 1),
          0 !== i ? (c.isWalkableAt(l, p - 1) && f.push([l,
          p - 1]), c.isWalkableAt(l, p + 1) && f.push([l,
          p + 1]), c.isWalkableAt(l + i, p) && f.push([l + i,
          p]))  : 0 !== n && (c.isWalkableAt(l - 1, p) && f.push([l - 1,
          p]), c.isWalkableAt(l + 1, p) && f.push([l + 1,
          p]), c.isWalkableAt(l, p + n) && f.push([l,
          p + n]));
           else for (o = c.getNeighbors(t, !1), a = 0, u = o.length; u > a; ++a) s = o[a],
          f.push([s.x,
          s.y]);
          return f
        },
        e.exports = r
      },
      {
        '../core/Heuristic': 4,
        './JumpPointFinder': 16
      }
    ],
    
    18: [
      function (t, e) {
        function r(t) {
          t = t || {
          },
          this.allowDiagonal = t.allowDiagonal,
          this.dontCrossCorners = t.dontCrossCorners,
          this.heuristic = t.heuristic || o.manhattan,
          this.weight = t.weight || 1
        }
        var i = t('heap'),
        n = t('../core/Util'),
        o = t('../core/Heuristic');
       // o = t('../core/Heuristic');
        ast = function (t, e, r, o, s) {
         
                var a,
                u,
                h,
                l,
                p,
                c,
                f,
                d,
                heap = new i(function (t, e) {
                  return t.f - e.f
                }),
                st = s.getNodeAt(t, e),
                b = s.getNodeAt(r, o),
                A = this.heuristic,
                k = this.allowDiagonal,
                m = this.dontCrossCorners,
                v = this.weight,
                w = Math.abs,
                x = Math.SQRT2;
                
                for (st.g = 0, st.f = 0, heap.push(st), st.opened = !0; !heap.empty(); ) {
                  if (a = heap.pop(), a.closed = !0, a === b) return n.backtrace(b);
                  for (u = s.getNeighbors(a, k, m), l = 0, p = u.length; p > l; ++l) h = u[l],
                  h.closed || (c = h.x, f = h.y, d = a.g + (0 === c - a.x || 0 === f - a.y ? 1 : x), (!h.opened || d < h.g) && (h.g = d, h.h = h.h || v * A(w(c - r), w(f - o)), h.f = h.g + h.h, h.parent = a, h.opened ? heap.updateItem(h)  : (heap.push(h), h.opened = !0)))
                }
                return []
              
        },
        
      
      
        r.prototype.findPath = function (t, e, r, o, s) {
         var b=s.getNodeAt(r,o);
          var stops=[];
          stops.push(b);
          for(var i=0;i<40;i++){
            for(var j=0;j<60;j++){
              if(s.isNstopAt(j,i)==0){stops.push(s.getNodeAt(j,i));}
            }
          }
          //alert(stops.length);
          
          var p;
          var final=[];
        
          var PL=10000000;
          var node=b;
          
          for(var i=0;i<stops.length;i++){
            //var astar=new ast;
            var a=(ast(t,e,stops[i].x,stops[i].y,s));
            //p=(astar.findPath(t,e,stops[i].x,stops[i].y,s)).length;
            if(a.length<PL){
              final=a;
              
              node=stops[i];
            }
          }
          //alert(node.y)
         return final;
          for (y.g = 0, y.f = 0, g.push(y), y.opened = !0; !g.empty(); ) {
            if (a = g.pop(), a.closed = !0){
              for(var i=0;i<stops.length;i++){if(stops[i]===a)return n.backtrace(a);}
              
            } 
            for (u = s.getNeighbors(a, k, m), l = 0, p = u.length; p > l; ++l) h = u[l],
            h.closed || (c = h.x, f = h.y, d = a.g + (0 === c - a.x || 0 === f - a.y ? 1 : x), (!h.opened || d < h.g) && (h.g = d, h.h = h.h || v * A(w(c - r), w(f - o)), h.f = h.g + h.h, h.parent = a, h.opened ? g.updateItem(h)  : (g.push(h), h.opened = !0)))
          }
          return [];
        },
        e.exports = r
      },
      {
        '../core/Heuristic': 4,
        '../core/Util': 6,
       
        heap: 1
      }
    ],
    /*19: [
      function (t, e) {
        
        function r(t) {
          t = t || {
          },
          this.allowDiagonal = t.allowDiagonal,
          this.dontCrossCorners = t.dontCrossCorners
        }
        //var diag=t.allowDiagonal;
      var PL=10000000;
      var p=[];
      var util = t('../core/Util');
     // var nr=new r;

     r.prototype.findPath=function(t, e, r, n, grid) {
      var s,
      a,
      u,
      h,
      l,
      p = [
      ],
      c = this.allowDiagonal,
      f = this.dontCrossCorners,
      d = grid.getNodeAt(t, e),
      g = grid.getNodeAt(r, n);
      var stops=[];
      var l=1;
      
      //var e=grid.getNodeAt(endx,endy);
      stops.push(grid.getNodeAt(r,n));
     // var min=10000000000;
      //var min_dest=grid.getNodeAt(endx,endy);
      
      for(var i=0;i<40;i++){

      for(var j=0;j<60;j++){
      if(grid.isNstopAt(j,i)==0){l++;stops.push(grid.getNodeAt(j,i));}
      }
      }
      var vis=new Map([[d,1]]);
     //alert(stops.length);
      var par =new Map([[d,-1]]);
      var x=algo(d,stops,grid,vis,par);
      ;
      for(var i=0;i<x.length-1;i++){
          x[i].parent=x[i+1];
      }
      x[i].parent=0;
      
      return util.backtrace(x[0]);
      
    }
    
  
 

  
    bfs=  function(start,end,grid){
      var x=[];
        var vi=new Map([[start,1]]);
        var parent=new Map([]);
        var queue=[];
        queue.push(start);
        while(queue.length){
            var t1=queue.shift();
            if(t1==end){

                
                while(t1!=start){
                    x.push(t1);
                    t1=parent.get(t1);
                    
                }
                
               // x.reverse();
                
                return x;
            }
            var ne=[];
           // if(grid.isInside(t1.x+1,t1.y) && grid.isWalkableAt(t1.x+1,t1.y))ne.push(grid.getNodeAt(t1.x+1,t1.y));
            //if(grid.isInside(t1.x-1,t1.y) && grid.isWalkableAt(t1.x-1,t1.y))ne.push(grid.getNodeAt(t1.x-1,t1.y));
            //if(grid.isInside(t1.x,t1.y+1) && grid.isWalkableAt(t1.x,t1.y+1))ne.push(grid.getNodeAt(t1.x,t1.y+1));
            //if(grid.isInside(t1.x,t1.y-1) && grid.isWalkableAt(t1.x,t1.y-1))ne.push(grid.getNodeAt(t1.x,t1.y-1));
            ne = grid.getNeighbors(t1,this.allowDiagonal,this.dontCrossCorners);
            for (var i = 0;i<ne.length; ++i) {
                neighbor = ne[i];

                // skip this neighbor if it has been inspected before
                if (vi.has(neighbor)) {
                    continue;
                }

                queue.push(neighbor);
                vi.set(neighbor,1);
                parent.set(neighbor,t1);
              
            }
        
        }
        
    }
    algo=function (start,dest,grid,vis,par){
      var f=0;
      
     // var nr=new r;
      for(var i=0;i<dest.length;i++){
         // alert(vis[dest]);
          if(!(vis.has(dest[i])) || !(vis.get(dest[i]))){
              f=1;
              vis.set(dest[i],1);
              par.set(dest[i],start);
              //parent[dest[i]]=start;
              var a=algo(dest[i],dest,grid,vis,par);

              if(a.length<PL){
                //alert(2);
                  p=a;
                  PL=p.length;
              }
              vis.set(dest[i],0);
              par.set(dest[i],-1);
          }
      }
      if(f==0){
          var x=[];
         
         //x.push(start);
          //alert(x[0].x);
         // alert((parent.get(start)));
          while(par.get(start)!=-1){
           // var a=new r;
           //alert(1);
            // x.push(par.get(start));
              var x1=bfs(par.get(start),start,grid);
              for(var i=0;i<x1.length;i++)x.push(x1[i]);
              start=par.get(start);
          }
          x.push(start);
         
          return x;
          
      }
      else return p;
  },
  e.exports = r
},
  
      
        
      {
        '../core/Util': 6
      }
      /*function (t, e) {
        function r(t) {
          t = t || {
          },
          this.allowDiagonal = t.allowDiagonal,
          this.dontCrossCorners = t.dontCrossCorners
        }
        var i = t('../core/Util');
        var bfs=t('./BreadthFirstFinder');
                r.prototype.findPath = function (startx,starty,endx,endy, grid) {
        var stops=[];
        var l=1;
        var e=grid.getNodeAt(endx,endy);
        stops.push(grid.getNodeAt(endx,endy));
        var min=10000000000;
        var min_dest=grid.getNodeAt(endx,endy);
        start=grid.getNodeAt(startx,starty);
        for(var i=0;i<40;i++){
        for(var j=0;j<60;j++){
        if(grid.isNstopAt(j,i)==0){l++;stops.push(grid.getNodeAt(j,i));}
        }
        }
        var x=[];
        for(var k=0;k<l;k++){
          var y=new bfs;
          x=y.findPath(startx,starty,stops[k].x,stops[k].y,grid);
        if(min>x.length){
        min=x.length;
        min_dest=stops[k];
        }
        }
       
        //alert(e.x,e.y,min_dest.x,min_dest.y);
        
        return i.backtrace(min_dest);
        }
        e.exports = r
       },
       {
        '../core/Util': 6,
        './BreadthFirstFinder': 13
       }
    ],*/
    19: [
      function (t, e) {
        
        function r(t) {
          t = t || {
          },
          this.allowDiagonal = t.allowDiagonal,
          this.dontCrossCorners = t.dontCrossCorners
        }
        //var diag=t.allowDiagonal;
      var PL=10000000;
      var p=[];
      var util = t('../core/Util');
     // var nr=new r;

     r.prototype.findPath=function(t, e, r, n, grid) {
      var s,
      a,
      u,
      h,
      l,
      p = [
      ],
      c = this.allowDiagonal,
      f = this.dontCrossCorners,
      d = grid.getNodeAt(t, e),
      g = grid.getNodeAt(r, n);
      var stops=[];
      var l=1;
      
      //var e=grid.getNodeAt(endx,endy);
      stops.push(grid.getNodeAt(r,n));
     // var min=10000000000;
      //var min_dest=grid.getNodeAt(endx,endy);
      
      for(var i=0;i<40;i++){

      for(var j=0;j<60;j++){
      if(grid.isNstopAt(j,i)==0){l++;stops.push(grid.getNodeAt(j,i));}
      }
      }
      var vis=new Map([[d,1]]);
      alert(stops.length);
      var par =new Map([[d,-1]]);
      var x=algo(d,stops,grid,vis,par);
      //alert(x[1].length);
      var e = [
        [x[0].x,
        x[0].y]
      ]; 
      e.push([t.x,
      t.y]);
      for(var i=1;i<x.length;i++){
          e.push([x[i].x,x[i].y]);
         
          
      }
      
      return e;
      
    }
    
  
 

  
    bfs3=  function(start,end,grid){
      var x=[];
        var vi=new Map([[start,1]]);
        var parent=new Map([]);
        var queue=[];
        queue.push(start);
        while(queue.length){
            var t1=queue.shift();
            if(t1==end){

                
                while(t1!=start){
                    x.push(t1);
                    t1=parent.get(t1);
                    
                }
                
                return x;
            }
            var ne=[];
           // if(grid.isInside(t1.x+1,t1.y) && grid.isWalkableAt(t1.x+1,t1.y))ne.push(grid.getNodeAt(t1.x+1,t1.y));
            //if(grid.isInside(t1.x-1,t1.y) && grid.isWalkableAt(t1.x-1,t1.y))ne.push(grid.getNodeAt(t1.x-1,t1.y));
            //if(grid.isInside(t1.x,t1.y+1) && grid.isWalkableAt(t1.x,t1.y+1))ne.push(grid.getNodeAt(t1.x,t1.y+1));
            //if(grid.isInside(t1.x,t1.y-1) && grid.isWalkableAt(t1.x,t1.y-1))ne.push(grid.getNodeAt(t1.x,t1.y-1));
            ne = grid.getNeighbors(t1,this.allowDiagonal,this.dontCrossCorners);
            for (var i = 0;i<ne.length; ++i) {
                neighbor = ne[i];

                // skip this neighbor if it has been inspected before
                if (vi.has(neighbor)) {
                    continue;
                }

                queue.push(neighbor);
                vi.set(neighbor,1);
                parent.set(neighbor,t1);
              
            }
        
        }
        
    }
    algo=function (start,dest,grid,vis,par){
      var f=0;
      
     // var nr=new r;
      for(var i=0;i<dest.length;i++){
         // alert(vis[dest]);
          if(!(vis.has(dest[i])) || !(vis.get(dest[i]))){
              f=1;
              vis.set(dest[i],1);
              par.set(dest[i],start);
              //parent[dest[i]]=start;
              var a=algo(dest[i],dest,grid,vis,par);

              if(a.length<PL){
                  p=a;
                  PL=p.length;
              }
              vis.set(dest[i],0);
              par.set(dest[i],-1);
          }
      }
      if(f==0){
          var x=[];
          
          //alert(x[0].x);
         // alert((parent.get(start)));
          while(par.get(start)!=-1){
           // var a=new r;

           //x.push(par.get(start));
              var x1=bfs3(par.get(start),start,grid);
              for(var i=0;i<x1.length;i++)x.push(x1[i]);
              start=par.get(start);
              x.push(start);
          }
         // alert(x);
          return x;
          
      }
      else return p;
  },
  e.exports = r
},
  
      
        
      {
        '../core/Util': 6
      }
      /*function (t, e) {
        function r(t) {
          t = t || {
          },
          this.allowDiagonal = t.allowDiagonal,
          this.dontCrossCorners = t.dontCrossCorners
        }
        var i = t('../core/Util');
        var bfs=t('./BreadthFirstFinder');
                r.prototype.findPath = function (startx,starty,endx,endy, grid) {
        var stops=[];
        var l=1;
        var e=grid.getNodeAt(endx,endy);
        stops.push(grid.getNodeAt(endx,endy));
        var min=10000000000;
        var min_dest=grid.getNodeAt(endx,endy);
        start=grid.getNodeAt(startx,starty);
        for(var i=0;i<40;i++){

        for(var j=0;j<60;j++){
        if(grid.isNstopAt(j,i)==0){l++;stops.push(grid.getNodeAt(j,i));}
        }
        }
        var x=[];
        for(var k=0;k<l;k++){
          var y=new bfs;
          x=y.findPath(startx,starty,stops[k].x,stops[k].y,grid);

        if(min>x.length){
        min=x.length;
        min_dest=stops[k];
        }
        }
       
        //alert(e.x,e.y,min_dest.x,min_dest.y);
        
        return i.backtrace(min_dest);
        }
        e.exports = r
       },
       {
        '../core/Util': 6,
        './BreadthFirstFinder': 13
       }*/
    ],
    20: [
      function (t, e) {
        function r(t) {
          t = t || {
          },
          this.allowDiagonal = t.allowDiagonal,
          this.dontCrossCorners = t.dontCrossCorners,
          this.heuristic = t.heuristic || o.manhattan,
          this.weight = t.weight || 1
        }
        var heap = t('heap'),
        n = t('../core/Util'),
        o = t('../core/Heuristic');
        r.prototype.findPath = function (t, e, r, o, s) {
          var a,
          u,
          h,
          l,
          p,
          c,
          f,
          d,
          g = new heap(function (t, e) {
            return t.f - e.f
          }),
          y = s.getNodeAt(t, e),
          b = s.getNodeAt(r, o);
          var stops=[];
          stops.push(b);
          for(var i=0;i<40;i++){
            for(var j=0;j<60;j++){
              if(s.isNstopAt(j,i)==0){stops.push(s.getNodeAt(j,i));}
            }
          }
          A = this.heuristic,
          k = this.allowDiagonal,
          m = this.dontCrossCorners,
          v = this.weight,
          w = Math.abs,
          x = Math.SQRT2;
          for (y.g = 0, y.f = 0, g.push(y), y.opened = !0; !g.empty(); ) {
            if (a = g.pop(), a.closed = !0){
              for(var i=0;i<stops.length;i++){if(stops[i]===a)return n.backtrace(a);}
              
            } 
            for (u = s.getNeighbors(a, k, m), l = 0, p = u.length; p > l; ++l) h = u[l],
            h.closed || (c = h.x, f = h.y, d = a.g + (0 === c - a.x || 0 === f - a.y ? 1 : x), (!h.opened || d < h.g) && (h.g = d, h.h = h.h || v * A(w(c - r), w(f - o)), h.f = h.g + h.h, h.parent = a, h.opened ? g.updateItem(h)  : (g.push(h), h.opened = !0)))
          }
          return [];
        },
        e.exports = r
      },
      {
        '../core/Heuristic': 4,
        '../core/Util': 6,
        heap: 1
      }
    ],
    
    
    21: [
      function (t, e) {
        e.exports = {
          Heap: t('heap'),
          Node: t('./core/Node'),
          Grid: t('./core/Grid'),
          Util: t('./core/Util'),
          Heuristic: t('./core/Heuristic'),
          AStarFinder: t('./finders/AStarFinder'),
          BestFirstFinder: t('./finders/BestFirstFinder'),
          BreadthFirstFinder: t('./finders/BreadthFirstFinder'),
          DijkstraFinder: t('./finders/DijkstraFinder'),
          BiAStarFinder: t('./finders/BiAStarFinder'),
          BiBestFirstFinder: t('./finders/BiBestFirstFinder'),
          BiBreadthFirstFinder: t('./finders/BiBreadthFirstFinder'),
          BiDijkstraFinder: t('./finders/BiDijkstraFinder'),
         Multi1_astar: t('./finders/Multi1_astar'),
          Multi1: t('./finders/Multi1'),
          Multi3: t('./finders/Multi3'),
          Multi2: t('./finders/Multi2'),
          OrthogonalJumpPointFinder: t('./finders/OrthogonalJumpPointFinder'),
          
        }
      },
      {
        './core/Grid': 3,
        './core/Heuristic': 4,
        './core/Node': 5,
        './core/Util': 6,
        './finders/AStarFinder': 7,
        './finders/BestFirstFinder': 8,
        './finders/BiAStarFinder': 9,
        './finders/BiBestFirstFinder': 10,
        './finders/BiBreadthFirstFinder': 11,
        './finders/BiDijkstraFinder': 12,
        './finders/BreadthFirstFinder': 13,
        './finders/DijkstraFinder': 14,
        './finders/Multi1_astar': 18,
        './finders/Multi3': 19,
        './finders/OrthogonalJumpPointFinder': 17,
        './finders/Multi1': 16,
        './finders/Multi2': 15,
        
        heap: 1
      }
    ]
  }, {
  }, [
    21
  ]) (21)
});
